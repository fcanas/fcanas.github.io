<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="2016-10-24">
  <title>Software Engineering</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="/writ.min.css">
</head>
<body>
<header>
<h1>fabián cañas</h1>
<nav>
<ul>
  <li><a href='/'>about</a></li>
  <li><a href='/blog/'>writing</a></li>
  <li><a href='/software/'>software</a></li>
  |
  <li><a href='https://www.github.com/fcanas'>GitHub</a></li>
  <li><a href='https://www.twitter.com/fcanas'>Twitter</a></li>
</ul>
</nav>
</header>
<main>
<article>
<h1>Software Engineering</h1>
<p>These are some of my observations and thoughts about best-practices for software<br />
engineering.</p>
<h2 id="er-er">Er-er</h2>
<p>Classes that end in <em>er</em> are suspicious. Especially managers and controllers.<br />
They tend to have more than one responsibility to begin with, and easily<br />
accumulate more responsibilities by being easy targets to match against new<br />
functionality. &quot;Manager&quot; and &quot;Controller&quot; are so non-specific as to be<br />
completely invisible when you're looking around a code base looking for where to<br />
put a new little bit of code. A <code>SearchManager</code> or <code>SearchController</code> are<br />
only bound by the general domain of &quot;something having to do with search&quot;.</p>
<p>For OOP, consider instead decomposing search into <code>Query</code>, <code>SearchParameters</code>,<br />
<code>Result</code>, and so on.</p>
<h2 id="logging-is-a-side-effect">Logging is a side-effect</h2>
<p>Logging is a side effect. And depending on how you're logging, it's possibly<br />
adding a dependency, or strongly coupling a domain, ui, or other component to a<br />
logging component. Especially deep in domain models, consider surfacing all the<br />
information needed to log, all errors for example. And logging further out in<br />
the stack.</p>
<h2 id="always-return">Always Return</h2>
<p>Methods with a <code>void</code> return are suspicious. They're guaranteed to have<br />
side-effects if they're at all useful. I'd like to practice a convention where<br />
<code>void</code> methods return <code>self</code> instead. This makes chaining easier. <code>void</code> methods<br />
that take arguments may be better off returning the arguments themselves, though<br />
I'm inclined towards <code>self</code>. This needs more thought.</p>
<p>Methods with a <code>void</code> return that don't take arguments are doubly suspicious.<br />
They are a very procedural in nature, and in my experience are an OOP trap into<br />
spaghetti code. That's not to say that these are forbidden. It can be very<br />
useful to capture a bit of repetitive code out of an object. But be vigilant as<br />
to whether a different pattern may be appropriate, such as a state machine.</p>
<h2 id="use-self-in-methods">Use Self in Methods</h2>
<p>If an instance method doesn't use <code>self</code>, it shouldn't be an instance method.<br />
Maybe it should be a class method, or a free function. But examine what<br />
structure it operates on and you may find it should be an extension on that<br />
type.</p>
</article>
</main>
</body>
</html>
