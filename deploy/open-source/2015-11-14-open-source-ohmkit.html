---
layout: page
title: OHMKit
categories: []
tags: []
status: publish
type: page
published: true
meta: {}
---
<h1 id="ohmkitadatapreservehtmlnodetruehrefhttpsgithubcomfcanasohmkittarget_blankclasssocialgithuba">OHMKit <a href="https://github.com/fcanas/OHMKit" target="_blank" class="social-github"></a></h1>

<p><a href="https://travis-ci.org/fcanas/OHMKit"><img src="http://img.shields.io/travis/fcanas/OHMKit.svg?style=flat" alt="CI Status" title=""></a>
<a href="http://cocoadocs.org/docsets/OHMKit"><img src="https://img.shields.io/cocoapods/v/OHMKit.svg?style=flat" alt="Version" title=""></a>
<a href="http://cocoadocs.org/docsets/OHMKit"><img src="https://img.shields.io/cocoapods/l/OHMKit.svg?style=flat" alt="License" title=""></a>
<a href="http://cocoadocs.org/docsets/OHMKit"><img src="https://img.shields.io/cocoapods/p/OHMKit.svg?style=flat" alt="Platform" title=""></a></p>

<p>OHMKit makes it easy to hydrate Objective-C model objects from web services or local files. It works especially well with JSON. It's a lot like <a href="https://github.com/Mantle/Mantle">Mantle</a> and <a href="https://github.com/icanzilb/JSONModel">JSONModel</a> except that OHMKit doesn't require your models to inherit from a base class, making it more suitable for use with <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CoreData/cdProgrammingGuide.html">Core Data</a>, <a href="https://parse.com/">Parse</a>, <a href="http://realm.io/">Realm</a>, or other libraries that <em>do</em> require you to inherit from a base class.</p>

<p>OHMKit is a system for declaratively expressing how to translate data from JSON or plist to native Objective-C model objects. OHMKit does it without requiring your model to inherit from a base class, so it works with NSObjects, NSManagedObjects, or anything else that fits with your class hierarchy. And you can specify custom mappings anywhere you want, not just in the model. So you can keep the details of mapping a service to you models out of your model code and in your service code where it may be more appropriate.</p>

<p>Fit this JSON</p>

<pre>{
  "name": "Fabian",
  "favorite_word":  "absurd",
  "favorite_number": 47
}
</pre>

<p>into this object</p>

<pre>@interface MYModel : NSObject
@property (nonatomic, strong) NSString *name;
@property (nonatomic, strong) NSString *favoriteWord;
@property (nonatomic, assign) NSInteger favoriteNumber;
@end
</pre>

<p>Map <code>user_name</code> from your web service to <code>userName</code> in your Objective-C models. Map a dictionary of numbers to a <code>UIColor</code>. Or hydrate a whole hierarchical JSON response, including arrays, dictionaries, and arbitrarily deep hierarchies of real Objective-C objects ... with a single line of code.</p>

<h2 id="why">Why?</h2>

<p>OHMKit exists because <a href="https://github.com/RestKit/RestKit">RestKit</a> (which is awesome by the way), is sometimes too big, heavy, and indirect. Because <a href="https://github.com/Mantle/Mantle">Mantle</a> and <a href="https://github.com/icanzilb/JSONModel">JSONModel</a> require your models to inherit from a base class.</p>

<p>Because sometimes, the web services your code consumes doesn't perfectly match your model objects.</p>

<p>OHMKit is under 200 lines of well-tested code being leveraged in the app store now in apps used by millions of users.</p>

<h3 id="whatohmkitisnot">What OHMKit is Not</h3>

<p>OHMKit doesn't know about networks. Use <a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>.</p>

<p>OHMKit doesn't know about routes. Use <a href="https://github.com/jverkoey/sockit">SOCKit</a>.</p>

<p>OHMKit doesn't know about JSON. Use <a href="https://developer.apple.com/library/ios/documentation/foundation/reference/nsjsonserialization_class/Reference/Reference.html">NSJSONSerialization</a></p>

<p>OHMKit doesn't know about CoreData. It will not manage graphs of entities for you quite like RestKit does. But OHMKit does not care about your model class' super class. So you can safely make subclasses of <code>NSManagedObject</code> mappable.</p>

<h2 id="usage">Usage</h2>

<h3 id="basicmapping">Basic Mapping</h3>

<p>Given a model</p>

<pre>@interface MYModel : NSObject
@property (nonatomic, strong) NSString *name;
@property (nonatomic, strong) NSString *favoriteWord;
@property (nonatomic, assign) NSInteger favoriteNumber;
@end
</pre>

<p>Anywhere in you application, make the model mappable, and assign it a dictionary of mappings from the keys a service will provide to the keys your actual model object uses. </p>

<pre>OHMMappable([MYModel class]);
OHMSetMapping([MYModel class], @{@"favorite_word"  : @"favoriteWord",
                                 @"favorite_number": @"favoriteNumber");
</pre>

<p>And now <em>anywhere</em> in your application, objects of the class <code>MYModel</code> can be hydrated with a dictionary from a service whose keys will be translated by the mapping dictionary you provided.</p>

<pre>MYModel *testModel = [[MYModel alloc] init];

[testModel setValuesForKeysWithDictionary:@{@"name"           : @"Fabian",
                                            @"favorite_word"  : @"absurd",
                                            @"favorite_number": @47];
</pre>

<h3 id="recursivemapping">Recursive Mapping</h3>

<p>Recursive mapping of mappable objects comes for free. If an object conforming to <code>&lt;OMMappable&gt;</code> has a property whose type also conforms to <code>&lt;OMMappable&gt;</code>, and the value for that key in the hydration dictionary is itself a dictionary, we'll instantiate a new model object and hydrate it. </p>

<pre>@interface MYClass : NSObject
@property (nonatomic, strong) NSString *name;
@end

@interface MYClass2 : NSObject
@property (nonatomic, strong) NSString *name;
@property (nonatomic, strong) NSString *favoriteWord;
@property (nonatomic, assign) NSInteger favoriteNumber;
@property (nonatomic, assign) MYClass *favoriteObject;
@end

OHMMappable([MYClass class]);

OHMMappable([MYClass2 class])
OHMSetMapping([MYClass2 class], @{@"favorite_word"  : @"favoriteWord", 
                                @"favorite_number": @"favoriteNumber", 
                                @"favorite_object" : @"favoriteObject"});

MYModel *testModel = [[MYClass2 alloc] init];

NSDictionary *class2Response = @{@"name"           : @"Fabian", 
                                 @"favorite_word"  : @"absurd", 
                                 @"favorite_number": @2, 
                                 @"favorite_object": @{@"name" : @"Rock"}};

[testModel setValuesForKeysWithDictionary:class2Response];
</pre>

<p>Now, <code>testModel.favoriteObject</code> is an instance of <code>MYClass</code> hydrated with "Rock" as its name.</p>

<p>Internally, the new model object is initialized with <code>[[ alloc] init]</code>, and then hydrated with <code>[ setValuesForKeysWithDictionary:dictionary]</code>. If you have a model that needs special consideration for initialization, use an adapter block.</p>

<h3 id="arrays">Arrays</h3>

<p>Arrays of dictionaries can be mapped to a class as well.</p>

<pre>@interface Person : NSObject
@property (nonatomic, copy) NSString *name;
@end

@interface Roster : NSObject
@property (nonatomic, strong) NSArray *people;
@end

OHMMappable([Person class]);
OHMSetArrayClasses([Roster class], @{@"people":[Person class]});

NSDictionary *response = @{@[@{@"name":@"Bert"},
                             @{@"name":@"Ernie"},
                             @{@"name":@"Count"}];

Roster *roster = [Roster new];
[roster setValuesForKeysWithDictionary:response];
</pre>

<h3 id="blocksserveasadapterstohandlespecialproperties">Blocks serve as adapters to handle special properties</h3>

<p>Users can pass a dictionary of blocks for field requiring special handling. Say a service sends back a dictionary that looks something like this:</p>

<pre>{
    "favorite_color": [
        122,
        50,
        80
    ],
    "least_favorite_color": [
        121,
        51,
        81
    ]
}
</pre>

<p>and we expect to map it to a model like this</p>

<pre>@interface MYModel : NSObject
@property (nonatomic, strong) UIColor *favoriteColor;
@property (nonatomic, strong) UIColor *leastFavoriteColor;
@end
</pre>

<p>You can adapt the response with an adapter block:</p>

<pre>OHMMappable([MYModel class]);
OHMSetMapping([MYModel class], @"least_favorite_color" : @"leastFavoriteColor", @"favorite_color" : @"favoriteColor")
OHMValueAdapterBlock colorFromNumberArray = ^(NSArray *numberArray) {
    return [UIColor colorWithRed:[numberArray[0] integerValue]/255.0
                           green:[numberArray[1] integerValue]/255.0
                            blue:[numberArray[2] integerValue]/255.0
                           alpha:1];
};
OHMSetAdapter([MYModel class], @{@"favoriteColor": colorFromNumberArray, @"leastFavoriteColor": colorFromNumberArray});
</pre>

<p>Note that the key for the adapter is the key on the model object, not on the response. And adapters are added for a property, not a type. If the above example had multiple properties that were colors, you would have to set an adapter block for each property. It would be smart to reuse adapter blocks in your code.</p>

<p>The <code>OHMValueAdapterBlock</code> type is a block that takes an <code>id</code> and returns an <code>id</code>. <em>i.e</em> <code>typedef id(^OHMValueAdapterBlock)(id);</code></p>

<h2 id="usingitinaproject">Using it in a project</h2>

<p>Use <a href="http://www.cocoapods.org">CocoaPods</a>, add OHMKit to your <code>PodFile</code>, and run <code>$ pod install</code></p>

<pre>pod 'OHMKit'
</pre>

<h2 id="how">How?</h2>

<p>OHMKit is a <a href="http://en.wikipedia.org/wiki/Mixin">mixin</a> that makes it easy to keep any direct knowledge of the idiosyncrasies of the service you're consuming tucked away in a single place. </p>

<p>It leverages the power of Key Value Coding (<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html">KVC</a>) that's built right in to Cocoa. It safely wraps <code>-setValue:forKey:</code> and <code>-setValue:forUndefinedKey:</code> to make calls to <code>setValuesForKeysWithDictionary:</code> extremely powerful.</p>

<h2 id="contributing">Contributing</h2>

<p>Bug fixes, pull requests, enhancement requests and feedback are welcome. </p>

<p>If you plan on contributing code, please notice that OHMKit has tests. If you're fixing a bug, please include a test that exposes the bug and therefore guards against a regression.</p>

<h2 id="todo">TODO</h2>

<h3 id="undefinedkeys">Undefined Keys</h3>

<p>The behavior of undefined keys should be configurable at 3 levels:</p>

<ol>
<li>Raise, because I should know about everything.</li>
<li>Drop unrecognized keys. We don't need them, but we shouldn't crash.</li>
<li>Add keys to a dictionary so that serialization/deserialization can be symmetric</li>
</ol>

<p>Option 2 is currently the only behavior, and I'm inclined to leave is as the default behavior.</p>

<h3 id="nscoding">NSCoding</h3>

<p>It might be nice if we built a way to make a class <code>NSCoding</code> compatible if it's not already. I like <a href="https://github.com/github/Mantle">Mantle</a>, but I don't want to be told what my super class should be.</p>

<h3 id="nsvaluetransformer">NSValueTransformer</h3>

<p>Adapter blocks versus <code>NSValueTransformer</code>s. There's no reason why both can't co-exist.</p>

<h1 id="license">License</h1>

<p>Copyright (c) 2013-2015 Fabian Canas. All rights reserved.</p>

<p>This code is distributed under the terms and conditions of the MIT license.</p>

<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>

<p>The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.</p>

<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.</p>
